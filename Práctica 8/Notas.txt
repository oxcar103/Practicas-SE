(Mirando MC1322xRM.pdf, sección 13.8 UART Register Memory Map)
UART1 base address = 0x8000_5000.
UART2 base address = 0x8000_B000.
Definimos uart_regs_t usando la tabla 13-6. UART Module Register Memory Map y la sección 13.9 UART Registers
Usaremos el tipo uint32

Para inicializar la UART, necesitamos cumplir 4 pasos básicos: Deshabilitamos la uart, Configuramos los parámetros, Habilitamos la uart, Asignamos los pines a la UART y Definimos la dirección de los pines.
Podemos ver en la sección 13.4.3 Basic Operation del manual que para establecer nuevos valores de INC/MOD es necesario desactivarla. Esto es, poner los bits RxE y TxE a 0. También es importante desactivar las interrupciones y esto se hace poniendo MTxR y MRxR a 1 como podemos ver en la sección 13.9.1 UART Control Register (UCON). Como el valor del resto de valores de UCON debería ser por defecto a 0, usamos la instrucción uart_regs[uart]->CON = (1 << 13) | (1 << 14) ya que MTxR y MRxR son respectivamente los registros 13 y 14.
Para calcular el valor de INC/MOD, visitamos la sección 13.4.2 Baud Rate Generation (Fractional Divider) donde nos explica cómo se calcula el baudrate a partir del Peripheral_Bus_Blk, MOD e INC. Mirando las tablas Table 13-2. Standard Baud Rates for 8x Oversampling y Table 13-3. Standard Baud Rates for 16x Oversampling podemos ver que MOD se fija a 9999 por algún motivo y podemos despejar INC a partir de la fórmula anterior una vez fijado un oversampling (8x) y un Peripheral_Bus_Blk (24 MHz). Después, sólo nos queda almacenarlo en los registros oportunos.
Antes de establecer las funciones a los pin de la UART, como queremos usar el modo alternate_1, podemos ver en 11.4.1.2 Alternate Modes que es necesario que el dispositivo esté habilitado, es decir, los bits RxE y TxE estén a 1. Respecto a los bits 13 y 14, como aún no nos interesa que haya interrupciones(eso se implementará en el driver de nivel 1), los dejamos desactivados, como estaban.
Cambiar el modo de funcionamiento de los pines es básicamente hacer uso de la función gpio_set_pin_func(pin, modo) implementada en la práctica anterior y establecerlos como entrada o salida, de gpio_set_pin_dir_input(pin) o gpio_set_pin_dir_output(pin) respectivamente.

Para el caso de la lectura/escritura de un byte, esperamos a tener caracteres/huecos en la cola y después leemos/escribimos nosotros.
La lectura/escritura es básicamente el acceso a Rx_data/Tx_data del registro uart_regs[uart] respectivamente.

Para comprobar el correcto funcionamiento de esta práctica, haremos un programa que interactúa con nuestro ordenador usando la UART. Para ello, el programa tendrá que enviar mensajes, recibirlos y actuar en consecuencia.
Usando las funciones definidas actualmente en el bsp, tendríamos que enviar el mensaje caracter a caracter, y es un rollo hacerlo así, por lo que he implementado la función send_str() que básicamente hace lo mismo que uart_send_byte() (de hecho, la llama) pero con char * en lugar de char. Intenté hacer lo mismo para uart_receive_byte() mediante receive_str() pero ha dado errores de caracteres que no he sido capaz de resolver.
