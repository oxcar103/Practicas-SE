(Mirando MC1322xRM.pdf, sección 4.2 Features)
Sabíamos desde la práctica 1 que la dirección base de la RAM es 0x00400000
Ahora sabemos que hay 4 bloques contiguos llamados RAM0, RAM1, RAM2 y RAM3, que ocupan:
RAM0 = 8Kbytes  (0x2000)    (comienza en 0x00400000 + 0x0000 = 0x00400000)
RAM1 = 24Kbytes (0x6000)    (comienza en 0x00400000 + 0x2000 = 0x00402000)
RAM2 = 32Kbytes (0x8000)    (comienza en 0x00402000 + 0x6000 = 0x00408000)
RAM3 = 32Kbytes (0x8000)    (comienza en 0x00408000 + 0x8000 = 0x00410000)

Para crear una sección:
.rami :
{
    si = .;     // Los espacios a cada lado del "=" son importantes
} > rami

Para comprobar que los símbolos se han creado podemos usar:
    · "(arm-none-eabi-)nm <archivo ELF>"
    · "(arm-none-eabi-)readelf -s <archivo ELF>"
    · "(arm-none-eabi-)objdump -t <archivo ELF>"
Siendo nm el modo más conciso, ya que informa de los símbolos creados y su dirección.
Por otro lado, readelf es el más completo aportando además datos como tipo y visión(local o global) del símbolo.

Y una vez testeado (como nosotros no lo usaremos, lo comentamos)

Sustituir el uso de constantes por variables es relativamente sencillo(siempre y cuando tengas en cuenta que si nos les das un valor inicial... Kablammo! <referencia a Los Simpsons>), basta con:
    · Tener en cuenta indicar que debemos empezar la sección ".data" antes de declarar las variables.
    · En la definición, quitamos el ".set", sustituimos "," por ":" pues ahora el nombre de la constante pasa a ser una variable e introducimos la directiva ".word" (aunque podemos usar otras si el dato fuese half-word o byte).
    · Inicializar la variable, aunque sea con 0x0.
    · En las lecturas y escrituras, debemos cargar la etiqueta en un registro y después leer o escribir:
        ldr r4, =LABEL
        ldr/str r5, [r4]

(Mirando MC1322xRM.pdf, sección 11.6 GPIO Module Register Memory Map)
Para crear la sección gpio, tenemos que tener en cuenta que empieza en la dirección 0x80000000 y que tiene una longitud de 0x68 bytes (la última dirección empieza en base+0x64 y tiene longitud de 32 bits), es decir, 8*(6*16+8) = 832 bits = 0x340 bits, por simplificar, usaremos 0x400 = 1024 bits

Para generar el binario de nuestra aplicación, basta con hacer "objcopy <archivo .elf>" y mostrar con ghex el contenido de los distintos ficheros para ver que, efectivamente, se rellena con 0's. La diferencia entre el generado con .data en ram1 y el generado en ram0 es de 8228 bytes frente a 372 bytes. Adicionalmente, si creamos una sección .bss con los datos inicializados a 0, podemos comprimir aún más el binario, quitando 4 bytes por variable en esta sección (en mi caso, 2).

Adicionalmente, por recomendación del profesor, he decidido añadir una pila a mi programa aunque no era necesario para esta práctica.
La pila se crea en el script añadiendo:
        _ram_limit = ORIGIN(ram0) + LENGTH(ram0);       (Para calcular el final de la ram donde irá alojada)
        _stack_size = 0x400;        /* (1 KB) */        (En mi programa basta con una pila de 32 bits pero ya que te pones a hacer una pila...)

        .stack _ram_limit - _stack_size :               (_ram_limit - _stack_size para dejarla justo al final)
        {
            _stack_bottom = . ;
            . += _stack_size ;
            _stack_top = . ;                            (Este parámetro lo utilizaremos después para inicializar el registro sp)
        }

Ahora, en nuestro programa debemos añadir "ldr sp, =_stack_top" para inicializarla y "push/pop {<registros>}" para usarla. Además, podemos ver que no hay diferencia de tamaño (salvo las instrucciones en sí, es decir, 16 bytes) entre este programa y el que no tenía pila.

NOTA IMPORTANTE:
No olvides inicializar las variables
No olvides guardar y cargar lr si vas a llamar a una función dentro de otra
