LUCHA FEROZ POR LA EXTINCIÓN DE BÚFER!!!

La función uart_send() comprueba que sus argumentos son correctos y ajusta errno al valor correspondiente si no lo son. Si sus argumentos son válidos, escribe en uart_circular_tx_buffers[uart] tantos bytes como se le hayan indicado o hasta llenarlo y devuelve cuántos bytes ha copiado.
Análogamente, uart_receive() hace lo mismo pero leyendo uart_circular_rx_buffers[uart] con tantos bytes como se le hayan indicado o hasta vaciarlo.

Para fijar una función callback, comprobamos que la uart es correcta y la asignamos para recepción(rx) o transmisión(tx).

El funcionamiento de la ISR es simple:
  · Guardamos USTAT en una variable para que deje de quejarse.
  · Atendemos cada registro activo (en realidad somos unos guays y pasamos de los errores pero se deberían atender)
  · Tanto para recepción como transmisión, el procedimiento es el mismo:
    - Copiar los que se puedan al/del buffer circular.
    - Callbacks. (IMPORTANTE: Sin los paréntesis, no llamamos a la función)
    - Desactivar interrupciones si fuese necesario.

Los cambios de la función uart_init() se resumen en:
  · Comprobación de parámetros correctos.
  · Inicialización de bufferes circulares.
  · Configuración de las interrupciones.
  · Inicialización de callbacks.

Debemos modificar las funciones definidas en la implementación de la capa L0 pues:
  · En el caso de lectura, debe mirar si hay datos primero en el buffer circular y luego en la cola FIFO, y bloquearse si la última no tiene.
  · En el caso de escritura, debe esperar a que se hayan escrito los caracteres que hay en el buffer circular antes de escribir el suyo.
  · En ambos casos, deben deshabilitar y restaurar las interrupciones para que no se le cuelen.

Para comprobar el correcto funcionamiento de esta práctica, haremos un programa que interactúa con nuestro ordenador usando la UART. Para ello, el programa configuraremos un callback que envia mensajes, los recibe y actuar en consecuencia mientras que el programa principal hace otras tares (en este caso, parpadear los leds pertinentes).
Nuestro callback, se encarga de comunicarse con la UART cada vez que nos llega un caracter. Lo leemos y en función de su valor, modificamos el comportamiento del led rojo (si nos llegó una 'r'), el del led verde (si nos llegó una 'g') o mandamos un mensaje de error reenviando de nuevos las instrucciones. Obviamente, este comportamiento tenemos que manejarlo nosotros mismos mediante variables de nuestro programa.
El programa principal, básicamente inicializa la GPIO, establece la callback que hemos implementado, manda por primera vez las instrucciones y hace parpadear los leds si su estado así lo permite.
Como en esta práctica también necesitamos acceder a la UART, grabaremos el programa en la memoria flash y usaremos un programa de comunicación en serie a nuestra elección configurado con los parámetros correspondientes.

De nuevo, el resumen para ejecutar el programa: make erase -> sudo chmod o+w /dev/ttyUSB1 -> make flash -> (resetear la placa) -> picocom -b 115200 -c /dev/ttyUSB1 -> (resetear la placa)
